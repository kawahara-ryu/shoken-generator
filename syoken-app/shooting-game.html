<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÈÄÜË•≤„ÅÆ„Ç¶„Çµ„ÇÆ</title>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-database-compat.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'DotGothic16', sans-serif;
        }

        canvas {
            display: block;
        }

        /* ===== UI Layer ===== */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            font-size: 24px;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
            pointer-events: none;
            z-index: 10;
        }

        /* ===== „Çø„Ç§„Éà„É´ÁîªÈù¢ ===== */
        #title-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 30;
            width: 90%;
            max-width: 700px;
        }

        /* ===== „Éú„Çø„É≥ÂÖ±ÈÄö ===== */
        button {
            background: transparent;
            color: #0ff;
            border: 1px solid #0ff;
            padding: 10px 20px;
            font-family: 'DotGothic16', sans-serif;
            font-size: 20px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
            text-shadow: 0 0 5px #0ff;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.3), inset 0 0 5px rgba(0, 255, 255, 0.1);
        }

        button:hover {
            background: rgba(0, 255, 255, 0.15);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5), inset 0 0 10px rgba(0, 255, 255, 0.2);
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
        }

        /* ===== „Éó„É¨„Ç§„É§„ÉºÂêçÂÖ•Âäõ ===== */
        #player-name-input {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #0ff;
            color: #0ff;
            font-family: 'DotGothic16', sans-serif;
            font-size: 22px;
            padding: 12px 20px;
            text-align: center;
            width: 300px;
            outline: none;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3), inset 0 0 10px rgba(0, 255, 255, 0.1);
            transition: box-shadow 0.3s ease;
        }

        #player-name-input:focus {
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6), inset 0 0 15px rgba(0, 255, 255, 0.2);
        }

        #player-name-input::placeholder {
            color: rgba(0, 255, 255, 0.4);
        }

        .diff-btn {
            font-size: 16px !important;
            padding: 8px 16px !important;
        }

        .diff-btn.selected {
            background: rgba(0, 255, 255, 0.2) !important;
            color: #fff !important;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6), inset 0 0 10px rgba(0, 255, 255, 0.3) !important;
        }

        /* ===== „É™„Ç∂„É´„ÉàÁîªÈù¢ ===== */
        #result-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(10, 0, 30, 0.97), rgba(0, 10, 40, 0.97));
            display: none;
            z-index: 50;
            overflow-y: auto;
        }

        #result-screen::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 255, 0.03) 2px, rgba(0, 255, 255, 0.03) 4px);
            pointer-events: none;
            z-index: 51;
        }

        .result-content {
            position: relative;
            z-index: 52;
            max-width: 600px;
            margin: 60px auto;
            padding: 20px;
            text-align: center;
        }

        @keyframes glitch {
            0% {
                text-shadow: 2px 0 #f0f, -2px 0 #0ff;
            }

            20% {
                text-shadow: -2px 0 #f0f, 2px 0 #0ff;
            }

            40% {
                text-shadow: 2px 2px #f0f, -2px -2px #0ff;
            }

            60% {
                text-shadow: -1px 1px #f0f, 1px -1px #0ff;
            }

            80% {
                text-shadow: 1px -2px #f0f, -1px 2px #0ff;
            }

            100% {
                text-shadow: 2px 0 #f0f, -2px 0 #0ff;
            }
        }

        @keyframes flicker {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.95;
            }

            52% {
                opacity: 0.6;
            }

            54% {
                opacity: 1;
            }
        }

        @keyframes neonPulse {

            0%,
            100% {
                text-shadow: 0 0 5px #0ff, 0 0 10px #0ff, 0 0 20px #0ff;
            }

            50% {
                text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px #0ff, 0 0 80px #0ff;
            }
        }

        @keyframes slideIn {
            from {
                transform: translateY(30px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .result-gameover {
            font-family: 'Orbitron', sans-serif;
            font-size: 56px;
            font-weight: 900;
            color: #f00;
            animation: glitch 0.3s infinite, flicker 3s infinite;
            margin-bottom: 10px;
            letter-spacing: 5px;
        }

        .result-comment {
            color: #888;
            font-size: 18px;
            margin-bottom: 30px;
            font-style: italic;
            animation: slideIn 0.5s ease 0.3s both;
        }

        .result-player {
            font-size: 28px;
            color: #f0f;
            margin-bottom: 5px;
            animation: glitch 0.5s infinite, slideIn 0.5s ease 0.5s both;
            letter-spacing: 2px;
        }

        .result-title {
            font-size: 20px;
            color: #ff0;
            margin-bottom: 20px;
            animation: slideIn 0.5s ease 0.7s both;
            text-shadow: 0 0 10px rgba(255, 255, 0, 0.5);
        }

        .result-score-box {
            border: 1px solid #0ff;
            padding: 25px;
            margin: 20px auto;
            max-width: 350px;
            background: rgba(0, 255, 255, 0.05);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2), inset 0 0 20px rgba(0, 255, 255, 0.05);
            animation: slideIn 0.5s ease 0.9s both;
        }

        .result-score-label {
            font-size: 14px;
            color: #0ff;
            letter-spacing: 3px;
            margin-bottom: 5px;
        }

        .result-score-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 64px;
            font-weight: 900;
            color: #0ff;
            animation: neonPulse 2s infinite;
        }

        .result-difficulty {
            font-size: 14px;
            color: #888;
            margin-top: 5px;
        }

        .ranking-section {
            margin-top: 30px;
            animation: slideIn 0.5s ease 1.1s both;
        }

        .ranking-section h3 {
            color: #0ff;
            font-size: 20px;
            letter-spacing: 3px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            margin-bottom: 15px;
        }

        .ranking-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        .ranking-table th {
            color: #0ff;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            padding: 8px 5px;
            font-weight: normal;
            letter-spacing: 2px;
            font-size: 12px;
        }

        .ranking-table td {
            color: #ccc;
            padding: 8px 5px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
        }

        .ranking-table tr.current-player td {
            color: #f0f;
            text-shadow: 0 0 5px rgba(255, 0, 255, 0.5);
        }

        .ranking-table .rank-god {
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .ranking-table .rank-sub-god {
            color: #c0c0c0;
            text-shadow: 0 0 8px rgba(192, 192, 192, 0.5);
        }

        .ranking-table .rank-ex-god {
            color: #cd7f32;
            text-shadow: 0 0 6px rgba(205, 127, 50, 0.5);
        }

        .result-buttons {
            margin-top: 30px;
            animation: slideIn 0.5s ease 1.3s both;
        }

        .result-buttons button {
            font-size: 22px;
            padding: 12px 30px;
        }

        /* ===== „É©„É≥„Ç≠„É≥„Ç∞Èñ≤Ë¶ßÁîªÈù¢ ===== */
        #ranking-viewer {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(10, 0, 30, 0.97), rgba(0, 10, 40, 0.97));
            display: none;
            z-index: 40;
            overflow-y: auto;
        }

        #ranking-viewer::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 255, 0.03) 2px, rgba(0, 255, 255, 0.03) 4px);
            pointer-events: none;
            z-index: 41;
        }

        .ranking-viewer-content {
            position: relative;
            z-index: 42;
            max-width: 600px;
            margin: 40px auto;
            padding: 20px;
            text-align: center;
        }

        .ranking-viewer-content h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 36px;
            color: #0ff;
            animation: neonPulse 2s infinite;
            letter-spacing: 5px;
            margin-bottom: 20px;
        }

        .tab-bar {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 20px;
        }

        .tab-btn {
            font-size: 14px !important;
            padding: 6px 14px !important;
        }

        .tab-btn.active {
            background: rgba(0, 255, 255, 0.2) !important;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5) !important;
        }
    </style>
</head>

<body>
    <!-- ===== „Çø„Ç§„Éà„É´ÁîªÈù¢ ===== -->
    <div id="title-screen">
        <h1
            style="font-family: 'Orbitron', sans-serif; font-size: 48px; color: #f0f; text-shadow: 0 0 10px #f0f, 0 0 20px #f0f, 0 0 40px #f0f; margin-bottom: 5px; letter-spacing: 3px;">
            „Ç¶„Çµ„ÇÆ„ÅÆÈÄÜË•≤</h1>
        <p style="color: #0ff; font-size: 18px; margin-bottom: 25px; text-shadow: 0 0 5px #0ff;">„ÄúËø´„Çä„Åè„ÇãÁå´„Åü„Å°„ÇíÊíÉÈÄÄ„Åõ„Çà„Äú</p>
        <div style="margin-bottom: 20px;">
            <p style="color: #0ff; font-size: 14px; letter-spacing: 2px; margin-bottom: 5px;">PLAYER NAME</p>
            <input type="text" id="player-name-input" placeholder="Âêç„ÇÇ„Å™„ÅçÊà¶Â£´" maxlength="12">
        </div>
        <div id="difficulty-selector" style="margin-bottom: 15px;">
            <p style="color: #ff0; font-size: 14px; letter-spacing: 2px; margin-bottom: 8px;">DIFFICULTY</p>
            <button class="diff-btn" data-diff="easy">Easy („ÇÜ„Å®„Çä)</button>
            <button class="diff-btn" data-diff="normal">Normal (‰∏ÄËà¨)</button>
            <button class="diff-btn" data-diff="hard">Hard (ÊÆãÊ•≠)</button>
            <button class="diff-btn" data-diff="veryhard" style="color: #f55;">VeryHard (ÈÄ£Âã§)</button>
            <button class="diff-btn" data-diff="alone" style="color: #f0f;">Alone (Â≠§Áã¨)</button>
        </div>
        <p id="diff-desc" style="color: #888; font-size: 14px; height: 20px; margin-bottom: 10px;"></p>
        <button id="start-btn" style="padding: 14px 50px; font-size: 28px; display: none; letter-spacing: 3px;">GAME
            START</button>
        <div style="margin-top: 20px;">
            <button id="ranking-btn" style="font-size: 16px; padding: 8px 25px; letter-spacing: 2px;">RANKING</button>
        </div>
    </div>

    <!-- ===== „Ç≤„Éº„É†‰∏≠UI ===== -->
    <div id="ui-layer" style="display: none;">
        „Çπ„Ç≥„Ç¢: <span id="score">0</span> Âåπ Ë®é‰ºê
        <span id="current-diff" style="font-size: 16px; color: #888; margin-left: 10px;"></span>
        <span id="timer-display" style="font-size: 16px; color: #ff0; margin-left: 15px;"></span>
    </div>

    <!-- ===== „É™„Ç∂„É´„ÉàÁîªÈù¢ ===== -->
    <div id="result-screen">
        <div class="result-content">
            <div class="result-gameover">GAME OVER</div>
            <div class="result-comment" id="result-comment"></div>
            <div class="result-player" id="result-player-name"></div>
            <div class="result-title" id="result-player-title"></div>
            <div class="result-score-box">
                <div class="result-score-label">SCORE</div>
                <div class="result-score-value" id="result-score-value">0</div>
                <div class="result-difficulty" id="result-difficulty-name"></div>
            </div>
            <div class="ranking-section">
                <h3>‚Äï RANKING ‚Äï</h3>
                <table class="ranking-table">
                    <thead>
                        <tr>
                            <th>RANK</th>
                            <th>NAME</th>
                            <th>TITLE</th>
                            <th>SCORE</th>
                        </tr>
                    </thead>
                    <tbody id="result-ranking-body"></tbody>
                </table>
            </div>
            <div class="result-buttons">
                <button onclick="location.reload()">„ÇÇ„ÅÜ„ÅÑ„Å°„Å©</button>
                <button onclick="location.href='index.html'">„ÇÇ„Å©„Çã</button>
            </div>
        </div>
    </div>

    <!-- ===== „É©„É≥„Ç≠„É≥„Ç∞Èñ≤Ë¶ßÁîªÈù¢ ===== -->
    <div id="ranking-viewer">
        <div class="ranking-viewer-content">
            <h2>RANKING</h2>
            <div class="tab-bar" id="ranking-tabs"></div>
            <table class="ranking-table">
                <thead>
                    <tr>
                        <th>RANK</th>
                        <th>NAME</th>
                        <th>TITLE</th>
                        <th>SCORE</th>
                    </tr>
                </thead>
                <tbody id="ranking-viewer-body"></tbody>
            </table>
            <div style="margin-top: 25px;">
                <button id="ranking-back-btn" style="font-size: 18px;">„ÇÇ„Å©„Çã</button>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ÁîªÂÉè
        const bgImg = new Image(); bgImg.src = 'rpg_map_bg.png';
        const playerImg = new Image(); playerImg.src = 'rabbit_pistol.png';
        const enemyImg = new Image(); enemyImg.src = 'cat_run.png';
        const bossImg = new Image(); bossImg.src = 'boss_cat.png';

        // „Ç∑„É•„Éº„É´„Å™Ë®ÄËëâ
        const surrealWords = ["ËôöÁÑ°", "ÂÆöÊôÇÈÄÄÁ§æ", "ÊúâÁµ¶Ê∂àÂåñ", "Ë≥áÊú¨‰∏ªÁæ©", "ÊâøË™çÊ¨≤Ê±Ç", "Êó¢Ë™≠„Çπ„É´„Éº", "ËÄÅÂæåË≥áÈáë", "„Ç≥„É≥„Éó„É©", "Á®éÈáë", "ÂÑ™Âãù", "Ë´ñÁ†¥", "ÈªíÊ≠¥Âè≤", "„Çµ„É®„Éä„É©", "ÁàÜÊï£", "Êàê‰ªè"];
        const bossWords = ["Êàë„ÅØÁ•û„Å™„Çä", "ÁÑ°ÈßÑÁÑ°ÈßÑ", "È†òÂüüÂ±ïÈñã", "Ëß£„Åõ„Å¨", "„Å´„ÇÉ„Éº„Çì"];
        const eliteWords = ["Èáë„ÅÆ‰∫°ËÄÖ", "ÊãùÈáë‰∏ªÁæ©", "„Éë„ÉØ„Éè„É©‰∏äÂè∏", "Ëª¢ËÅ∑Â§±Êïó", "ÈóáÂñ∂Ê•≠"];

        // Áß∞Âè∑
        function getTitle(s) {
            if (s >= 100) return "CEO of „Ç¶„Çµ„ÇÆ";
            if (s >= 50) return "ÂèñÁ∑†ÂΩπ";
            if (s >= 30) return "ÈÉ®Èï∑‰ª£ÁêÜ";
            if (s >= 15) return "‰∏≠ÈñìÁÆ°ÁêÜËÅ∑";
            if (s >= 5) return "Âπ≥Á§æÂì°";
            return "Á§æÁïúË¶ãÁøí„ÅÑ";
        }
        function getRankName(r) { return r === 1 ? "Á•û" : r === 2 ? "Ê∫ñÁ•û" : r === 3 ? "ÂÖÉÁ•û" : "Âá°‰∫∫"; }
        function getRankClass(r) { return r === 1 ? "rank-god" : r === 2 ? "rank-sub-god" : r === 3 ? "rank-ex-god" : ""; }

        const gameOverComments = {
            easy: "„ÇÜ„Å®„Çä„ÅÇ„Çã‰∫∫Áîü„Å†„Å£„Åü...",
            normal: "„ÅäÁñ≤„ÇåÊßò„Åß„Åó„Åü„ÄÇÊòéÊó•„ÇÇÂá∫Á§æ„Åß„Åô„ÄÇ",
            hard: "ÊÆãÊ•≠‰ª£„ÅØÂá∫„Åæ„Åõ„Çì„ÄÇ",
            veryhard: "Âä¥Âü∫„Å´ÈÄ£Áµ°„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
            alone: "„ÇÑ„Å£„Å±„Çä„ÄÅ„Å≤„Å®„Çä„Å†„Å£„Åü„ÄÇ"
        };

        // ===== FirebaseÂàùÊúüÂåñ =====
        const firebaseConfig = {
            apiKey: "AIzaSyBv0AE6vh3q478KnECzyClAfviYEUf42aQ",
            authDomain: "usagi-no-gyakushu.firebaseapp.com",
            databaseURL: "https://usagi-no-gyakushu-default-rtdb.firebaseio.com",
            projectId: "usagi-no-gyakushu",
            storageBucket: "usagi-no-gyakushu.firebasestorage.app",
            messagingSenderId: "890613344404",
            appId: "1:890613344404:web:bf78552cb4cdddfe7b2c81",
            measurementId: "G-TF8JT9HF02"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        // ===== „É©„É≥„Ç≠„É≥„Ç∞ÔºàFirebase Realtime DatabaseÔºâ =====
        async function getRanking(d) {
            try {
                const snapshot = await db.ref('ranking/' + d).orderByChild('score').limitToLast(10).once('value');
                const data = snapshot.val();
                if (!data) return [];
                const arr = Object.values(data);
                arr.sort((a, b) => b.score - a.score);
                return arr;
            } catch (e) {
                console.error('FirebaseË™≠Ëæº„Ç®„É©„Éº:', e);
                return [];
            }
        }

        async function saveRanking(d, entry) {
            try {
                await db.ref('ranking/' + d).push(entry);
                const snapshot = await db.ref('ranking/' + d).orderByChild('score').once('value');
                const data = snapshot.val();
                if (data) {
                    const entries = Object.entries(data);
                    entries.sort((a, b) => b[1].score - a[1].score);
                    if (entries.length > 10) {
                        const deletes = entries.slice(10);
                        for (const [key] of deletes) {
                            await db.ref('ranking/' + d + '/' + key).remove();
                        }
                    }
                }
                return await getRanking(d);
            } catch (e) {
                console.error('Firebase‰øùÂ≠ò„Ç®„É©„Éº:', e);
                return [];
            }
        }

        // ===== „Ç≤„Éº„É†Áä∂ÊÖã =====
        let gameState = 'TITLE';
        let score = 0, killCount = 0, frames = 0, spawnRate = 60;
        let bossActive = false, playerName = "Âêç„ÇÇ„Å™„ÅçÊà¶Â£´";
        let gameStartTime = 0; // „Ç≤„Éº„É†ÈñãÂßãÊôÇÂàªÔºàmsÔºâ
        let elapsedSeconds = 0; // ÁµåÈÅéÁßíÊï∞

        // ===== „Ç™„Éº„Éê„Éº„Éí„Éº„Éà„Ç∑„Çπ„ÉÜ„É† =====
        let heat = 0;           // 0„Äú100
        let overheated = false;  // „Ç™„Éº„Éê„Éº„Éí„Éº„Éà‰∏≠„Åã
        const HEAT_PER_SHOT = 18;
        const HEAT_COOLDOWN = 0.8; // ÊØé„Éï„É¨„Éº„É†ÂÜ∑„Åà„ÇãÈáè
        const OVERHEAT_THRESHOLD = 100;
        const OVERHEAT_RECOVERY = 50; // „Åì„ÅÆÂÄ§‰ª•‰∏ã„Åæ„ÅßÂÜ∑„Åà„Åü„ÇâÂæ©Â∏∞

        // ===== ÁîªÈù¢Á∏ÆÂ∞è =====
        let arenaMargin = 0; // ÁîªÈù¢Á´Ø„Åã„Çâ„ÅÆÂ£Å„ÅÆÂéö„Åï
        const ARENA_SHRINK_START = 30;  // 30ÁßíÂæå„Åã„ÇâÁ∏ÆÂ∞èÈñãÂßã
        const ARENA_SHRINK_RATE = 0.02; // „Éï„É¨„Éº„É†ÊØé„ÅÆ„Éû„Éº„Ç∏„É≥Â¢óÂä†Èáè
        const ARENA_MAX_MARGIN = 200;   // ÊúÄÂ§ß„Éû„Éº„Ç∏„É≥

        // Èõ£ÊòìÂ∫¶
        let difficulty = 'normal';
        const difficultySettings = {
            easy: { name: "„ÇÜ„Å®„Çä", spawn: 80, speedMulti: 0.8, bossHp: 5, desc: "„ÇÜ„Å£„Åè„ÇäÁîü„Åç„Åü„ÅÑ‰∫∫Âêë„Åë" },
            normal: { name: "‰∏ÄËà¨", spawn: 60, speedMulti: 1.0, bossHp: 10, desc: "ÊôÆÈÄö„ÅÆÁ§æ‰ºö‰∫∫ÁîüÊ¥ª" },
            hard: { name: "ÊÆãÊ•≠", spawn: 40, speedMulti: 1.3, bossHp: 20, desc: "ÁµÇ„Çè„Çâ„Å™„ÅÑ„Çø„Çπ„ÇØ„ÅÆÂ±±" },
            veryhard: { name: "ÈÄ£Âã§", spawn: 20, speedMulti: 1.8, bossHp: 50, desc: "ÂÆ∂„Å´Â∏∞„Çå„Å™„ÅÑÊó•„ÄÖ" },
            alone: { name: "Â≠§Áã¨", spawn: 10, speedMulti: 2.5, bossHp: 100, desc: "Ë™∞„ÇÇÂä©„Åë„Å¶„Åè„Çå„Å™„ÅÑ" }
        };

        const player = { x: canvas.width / 2, y: canvas.height / 2, size: 64, speed: 5 };
        let bullets = [], enemies = [], effects = [], enemyBullets = [];

        const keys = {};
        window.addEventListener('keydown', e => { keys[e.code] = true; if (e.code === 'Space') e.preventDefault(); });
        window.addEventListener('keyup', e => keys[e.code] = false);

        // DOM
        const titleScreen = document.getElementById('title-screen');
        const uiLayer = document.getElementById('ui-layer');
        const startBtn = document.getElementById('start-btn');
        const resultScreen = document.getElementById('result-screen');
        const diffBtns = document.querySelectorAll('.diff-btn');
        const diffDesc = document.getElementById('diff-desc');
        const currentDiffDisplay = document.getElementById('current-diff');
        const rankingViewer = document.getElementById('ranking-viewer');
        const nameInput = document.getElementById('player-name-input');
        const timerDisplay = document.getElementById('timer-display');

        diffBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                diffBtns.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                difficulty = btn.dataset.diff;
                diffDesc.textContent = difficultySettings[difficulty].desc;
                spawnRate = difficultySettings[difficulty].spawn;
                startBtn.style.display = 'inline-block';
            });
        });

        startBtn.addEventListener('click', () => {
            playerName = nameInput.value.trim() || "Âêç„ÇÇ„Å™„ÅçÊà¶Â£´";
            titleScreen.style.display = 'none';
            uiLayer.style.display = 'block';
            currentDiffDisplay.textContent = `[${difficultySettings[difficulty].name}]`;
            gameStartTime = Date.now();
            gameState = 'PLAYING';
            loop();
        });

        // „É©„É≥„Ç≠„É≥„Ç∞Èñ≤Ë¶ß
        document.getElementById('ranking-btn').addEventListener('click', () => {
            titleScreen.style.display = 'none';
            rankingViewer.style.display = 'block';
            showRankingViewer('easy');
            buildRankingTabs();
        });
        document.getElementById('ranking-back-btn').addEventListener('click', () => {
            rankingViewer.style.display = 'none';
            titleScreen.style.display = 'block';
        });

        function buildRankingTabs() {
            const tabBar = document.getElementById('ranking-tabs');
            tabBar.innerHTML = '';
            Object.keys(difficultySettings).forEach(key => {
                const btn = document.createElement('button');
                btn.className = 'tab-btn' + (key === 'easy' ? ' active' : '');
                btn.textContent = difficultySettings[key].name;
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    showRankingViewer(key);
                });
                tabBar.appendChild(btn);
            });
        }

        async function showRankingViewer(diff) {
            const tbody = document.getElementById('ranking-viewer-body');
            tbody.innerHTML = '<tr><td colspan="4" style="color:#555; padding:20px;">Ë™≠„ÅøËæº„Åø‰∏≠...</td></tr>';
            const ranking = await getRanking(diff);
            tbody.innerHTML = '';
            if (!ranking.length) { tbody.innerHTML = '<tr><td colspan="4" style="color:#555; padding:20px;">„Éá„Éº„Çø„Å™„Åó</td></tr>'; return; }
            ranking.forEach((e, i) => {
                const r = i + 1;
                const tr = document.createElement('tr');
                tr.innerHTML = `<td class="${getRankClass(r)}">${getRankName(r)}</td><td>${esc(e.name)}</td><td>${esc(e.title)}</td><td>${e.score}</td>`;
                tbody.appendChild(tr);
            });
        }

        function esc(s) { const d = document.createElement('div'); d.appendChild(document.createTextNode(s)); return d.innerHTML; }

        async function showResult() {
            const title = getTitle(score);
            const entry = { name: playerName, score, title, date: new Date().toISOString() };
            document.getElementById('result-comment').textContent = gameOverComments[difficulty];
            document.getElementById('result-player-name').textContent = playerName;
            document.getElementById('result-player-title').textContent = `‚Äï ${title} ‚Äï`;
            document.getElementById('result-score-value').textContent = score;
            document.getElementById('result-difficulty-name').textContent = `Èõ£ÊòìÂ∫¶: ${difficultySettings[difficulty].name}`;
            const tbody = document.getElementById('result-ranking-body');
            tbody.innerHTML = '<tr><td colspan="4" style="color:#555; padding:20px;">‰øùÂ≠ò‰∏≠...</td></tr>';
            resultScreen.style.display = 'block';
            const ranking = await saveRanking(difficulty, entry);
            tbody.innerHTML = '';
            ranking.slice(0, 5).forEach((e, i) => {
                const r = i + 1, tr = document.createElement('tr');
                if (e.name === playerName && e.score === score && e.date === entry.date) tr.className = 'current-player';
                tr.innerHTML = `<td class="${getRankClass(r)}">${getRankName(r)}</td><td>${esc(e.name)}</td><td>${esc(e.title)}</td><td>${e.score}</td>`;
                tbody.appendChild(tr);
            });
        }

        // ===== Âºæ„ÇØ„É©„Çπ =====
        class Bullet {
            constructor(x, y, angle) { this.x = x; this.y = y; this.speed = 15; this.angle = angle; this.size = 10; }
            update() { this.x += Math.cos(this.angle) * this.speed; this.y += Math.sin(this.angle) * this.speed; }
            draw() { ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(this.x, this.y, 5, 0, Math.PI * 2); ctx.fill(); }
        }

        // ===== ÊïµÂºæ„ÇØ„É©„ÇπÔºà„Éú„Çπ„ÅÆÁå´„Éë„É≥„ÉÅÂºæÔºâ =====
        class EnemyBullet {
            constructor(x, y, angle, speed) {
                this.x = x; this.y = y; this.angle = angle;
                this.speed = speed || 4; this.size = 12; this.life = 300;
            }
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.life--;
            }
            draw() {
                // Áå´„ÅÆÊâã„Å£„ÅΩ„ÅÑÂºæÔºà„Éî„É≥„ÇØ„ÅÆ‰∏∏ÔºãËÇâÁêÉÔºâ
                ctx.fillStyle = '#f0f';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff69b4';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
                ctx.fill();
                // „Ç∞„É≠„Éº
                ctx.shadowColor = '#f0f';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // ===== Êïµ„ÇØ„É©„Çπ =====
        class Enemy {
            constructor(type) {
                // type: 'normal', 'rush', 'elite', 'boss'
                this.type = type || 'normal';
                if (Math.random() < 0.5) {
                    this.x = Math.random() < 0.5 ? -50 : canvas.width + 50;
                    this.y = Math.random() * canvas.height;
                } else {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() < 0.5 ? -50 : canvas.height + 50;
                }
                this.size = 64;
                const setting = difficultySettings[difficulty];
                const timeScale = 1 + (elapsedSeconds / 60) * 0.5; // ÊôÇÈñìÁµåÈÅé„ÅßÂº∑Âåñ

                if (this.type === 'rush') {
                    this.speed = (6 + Math.random() * 3) * setting.speedMulti * timeScale;
                    this.hp = 1;
                    this.size = 48; // Â∞è„Åï„Åè„Å¶ÈÄü„ÅÑ
                } else if (this.type === 'elite') {
                    this.speed = (3 + Math.random() * 2) * setting.speedMulti * timeScale;
                    this.hp = 2;
                    this.size = 72; // „ÇÑ„ÇÑÂ§ß„Åç„ÅÑ
                } else {
                    this.speed = (2 + Math.random() * 2 + (score / 100)) * setting.speedMulti * timeScale;
                    this.hp = 1;
                }

                this.nyaText = "";
                this.isBoss = false;
                this.shootTimer = 0; // „Éú„ÇπÂºæÊíÉ„Å°„Çø„Ç§„Éû„Éº
            }

            update() {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }

                if (frames % 10 === 0 && !this.isBoss) {
                    if (this.type === 'rush') {
                        const rushNyas = ["ÔΩºÔΩ≠ÔæäÔæû", "Á™ÅÊíÉ„Å´„ÇÉ", "ÔæÄÔæûÔΩØÔΩºÔΩ≠!", "ÔæãÔæûÔΩ≠Ôæù"];
                        this.nyaText = rushNyas[Math.floor(Math.random() * rushNyas.length)];
                    } else if (this.type === 'elite') {
                        const eliteNyas = ["„Éï„É≥", "Âº±„ÅÑ", "ÈõëÈ≠ö„ÇÅ", "¬•¬•¬•"];
                        this.nyaText = eliteNyas[Math.floor(Math.random() * eliteNyas.length)];
                    } else {
                        const nyas = ["„Å´„ÇÉ", "„Å´„ÇÉÔΩû", "„Å´„ÇÉ„ÅÇ", "NYA"];
                        this.nyaText = nyas[Math.floor(Math.random() * nyas.length)];
                    }
                }

                // „Éú„Çπ„ÅÆÂºæÂπï: 2Áßí„Åî„Å®„Å´ÊîæÂ∞ÑÁä∂ÂºæÂπï
                if (this.isBoss) {
                    this.shootTimer++;
                    if (this.shootTimer >= 120) { // 2Áßí„Åî„Å®
                        this.shootTimer = 0;
                        const bulletCount = 8 + Math.floor(elapsedSeconds / 30) * 2; // ÊôÇÈñì„ÅßÂºæÂπïÂ¢óÂä†
                        for (let i = 0; i < bulletCount; i++) {
                            const angle = (Math.PI * 2 / bulletCount) * i + (frames * 0.01); // ÂõûËª¢„Åô„ÇãÂºæÂπï
                            enemyBullets.push(new EnemyBullet(this.x, this.y, angle, 3));
                        }
                        effects.push(new Effect(this.x, this.y, "Áå´„Éë„É≥„ÉÅÔºÅÔºÅ"));
                    }
                }
            }

            draw() {
                const img = this.isBoss ? bossImg : enemyImg;
                if (img.complete && img.naturalWidth !== 0) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.clip();
                    let drawX = this.x - this.size / 2, drawY = this.y - this.size / 2;
                    if (this.isBoss) { drawX += (Math.random() - 0.5) * 5; drawY += (Math.random() - 0.5) * 5; }
                    ctx.drawImage(img, drawX, drawY, this.size, this.size);
                    ctx.restore();

                    // „Ç®„É™„Éº„ÉàÁå´„Å´ÈáëËâ≤„Éú„Éº„ÉÄ„Éº
                    if (this.type === 'elite') {
                        ctx.strokeStyle = '#ffd700';
                        ctx.lineWidth = 3;
                        ctx.shadowColor = '#ffd700';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                    // Á™ÅÈÄ≤Áå´„Å´Ëµ§„ÅÑËªåË∑°
                    if (this.type === 'rush') {
                        ctx.strokeStyle = 'rgba(255,0,0,0.5)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size / 2 + 5, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                } else {
                    ctx.fillStyle = this.isBoss ? '#f00' : this.type === 'elite' ? '#ffd700' : this.type === 'rush' ? '#f55' : '#ff9900';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // „ÉÜ„Ç≠„Çπ„ÉàÊèèÁîª
                if (!this.isBoss) {
                    ctx.save();
                    ctx.font = this.type === 'rush' ? '18px DotGothic16' : '24px DotGothic16';
                    ctx.fillStyle = this.type === 'elite' ? '#ffd700' : this.type === 'rush' ? '#f55' : '#f00';
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 3; ctx.textAlign = 'center';
                    const jx = (Math.random() - 0.5) * 10, jy = (Math.random() - 0.5) * 10;
                    ctx.strokeText(this.nyaText, this.x + jx, this.y - 45 + jy);
                    ctx.fillText(this.nyaText, this.x + jx, this.y - 45 + jy);
                    ctx.restore();
                }

                // „Éú„ÇπHP„Éê„Éº
                if (this.isBoss) {
                    const maxHp = difficultySettings[difficulty].bossHp;
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x - 50, this.y - this.size / 2 - 20, 100 * (this.hp / maxHp), 10);
                    ctx.strokeStyle = '#0ff';
                    ctx.strokeRect(this.x - 50, this.y - this.size / 2 - 20, 100, 10);
                }
                // „Ç®„É™„Éº„ÉàHP„Éê„Éº
                if (this.type === 'elite' && this.hp > 0) {
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(this.x - 20, this.y - this.size / 2 - 12, 40 * (this.hp / 2), 5);
                    ctx.strokeStyle = '#fff';
                    ctx.strokeRect(this.x - 20, this.y - this.size / 2 - 12, 40, 5);
                }
            }
        }

        function spawnBoss() {
            const boss = new Enemy('normal');
            boss.isBoss = true;
            boss.type = 'boss';
            boss.size = 200;
            boss.hp = difficultySettings[difficulty].bossHp;
            boss.speed = 1.5 * difficultySettings[difficulty].speedMulti;
            enemies.push(boss);
            bossActive = true;
            effects.push(new Effect(canvas.width / 2, canvas.height / 2, "„Éú„ÇπÁå´Âá∫ÁèæÔºÅÔºÅ"));
        }

        class Effect {
            constructor(x, y, text) { this.x = x; this.y = y; this.text = text; this.life = 60; this.vy = -1; }
            update() { this.y += this.vy; this.life--; }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life / 60);
                ctx.fillStyle = '#fff'; ctx.strokeStyle = '#000'; ctx.lineWidth = 4;
                ctx.font = '28px DotGothic16';
                ctx.strokeText(this.text, this.x - 30, this.y);
                ctx.fillText(this.text, this.x - 30, this.y);
                ctx.globalAlpha = 1.0;
            }
        }

        // ===== „Ç™„Éº„Éê„Éº„Éí„Éº„Éà„Ç≤„Éº„Ç∏ÊèèÁîª =====
        function drawHeatGauge() {
            const gx = canvas.width - 180, gy = 30, gw = 150, gh = 16;
            // ËÉåÊôØ
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(gx, gy, gw, gh);
            // „Ç≤„Éº„Ç∏
            const ratio = heat / OVERHEAT_THRESHOLD;
            const color = overheated ? '#f00' : (ratio > 0.7 ? '#f80' : '#0f0');
            ctx.fillStyle = color;
            ctx.fillRect(gx, gy, gw * ratio, gh);
            // Êû†
            ctx.strokeStyle = overheated ? '#f00' : '#0ff';
            ctx.lineWidth = 1;
            ctx.strokeRect(gx, gy, gw, gh);
            // „É©„Éô„É´
            ctx.fillStyle = overheated ? '#f00' : '#0ff';
            ctx.font = '12px DotGothic16';
            ctx.textAlign = 'right';
            ctx.fillText(overheated ? 'üî• OVERHEAT!' : 'HEAT', gx - 5, gy + 13);
            ctx.textAlign = 'left';
        }

        // ===== ÁîªÈù¢Á∏ÆÂ∞è„ÅÆÂ£ÅÊèèÁîª =====
        function drawArenaWalls() {
            if (arenaMargin <= 0) return;
            ctx.fillStyle = 'rgba(255,0,100,0.15)';
            // ‰∏ä
            ctx.fillRect(0, 0, canvas.width, arenaMargin);
            // ‰∏ã
            ctx.fillRect(0, canvas.height - arenaMargin, canvas.width, arenaMargin);
            // Â∑¶
            ctx.fillRect(0, 0, arenaMargin, canvas.height);
            // Âè≥
            ctx.fillRect(canvas.width - arenaMargin, 0, arenaMargin, canvas.height);

            // „Éç„Ç™„É≥„Éú„Éº„ÉÄ„Éº
            ctx.strokeStyle = `rgba(255,0,100,${0.3 + Math.sin(frames * 0.05) * 0.2})`;
            ctx.lineWidth = 2;
            ctx.strokeRect(arenaMargin, arenaMargin, canvas.width - arenaMargin * 2, canvas.height - arenaMargin * 2);

            // Ë≠¶Âëä„ÉÜ„Ç≠„Çπ„Éà
            if (arenaMargin > 30 && frames % 60 < 30) {
                ctx.fillStyle = '#f06';
                ctx.font = '14px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText('‚ö† AREA SHRINKING ‚ö†', canvas.width / 2, arenaMargin - 5);
            }
        }

        // ===== „É°„Ç§„É≥„É´„Éº„Éó =====
        function loop() {
            if (gameState !== 'PLAYING') return;

            // ÊôÇÈñìÁµåÈÅéË®àÁÆó
            elapsedSeconds = (Date.now() - gameStartTime) / 1000;
            timerDisplay.textContent = `${Math.floor(elapsedSeconds)}Áßí`;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ËÉåÊôØ
            if (bgImg.complete && bgImg.naturalWidth !== 0) {
                const bgRatio = bgImg.width / bgImg.height;
                const canvasRatio = canvas.width / canvas.height;
                let dW, dH, dX, dY;
                if (canvasRatio > bgRatio) { dW = canvas.width; dH = canvas.width / bgRatio; dX = 0; dY = (canvas.height - dH) / 2; }
                else { dW = canvas.height * bgRatio; dH = canvas.height; dX = (canvas.width - dW) / 2; dY = 0; }
                ctx.drawImage(bgImg, dX, dY, dW, dH);
            }

            // ÁîªÈù¢Á∏ÆÂ∞è
            if (elapsedSeconds > ARENA_SHRINK_START && arenaMargin < ARENA_MAX_MARGIN) {
                arenaMargin += ARENA_SHRINK_RATE;
            }
            drawArenaWalls();

            // Player movement (Â£Å„ÅÆÁØÑÂõ≤ÂÜÖ„Å´Âà∂Èôê)
            if (keys['ArrowUp']) player.y -= player.speed;
            if (keys['ArrowDown']) player.y += player.speed;
            if (keys['ArrowLeft']) player.x -= player.speed;
            if (keys['ArrowRight']) player.x += player.speed;
            const minX = arenaMargin + player.size / 2, maxX = canvas.width - arenaMargin - player.size / 2;
            const minY = arenaMargin + player.size / 2, maxY = canvas.height - arenaMargin - player.size / 2;
            player.x = Math.max(minX, Math.min(maxX, player.x));
            player.y = Math.max(minY, Math.min(maxY, player.y));

            // „Ç™„Éº„Éê„Éº„Éí„Éº„Éà„ÇØ„Éº„É´„ÉÄ„Ç¶„É≥
            if (heat > 0) heat = Math.max(0, heat - HEAT_COOLDOWN);
            if (overheated && heat <= OVERHEAT_RECOVERY) overheated = false;

            // ShootingÔºà„Ç™„Éº„Éê„Éº„Éí„Éº„ÉàÂà∂Ôºâ
            if (keys['Space'] && frames % 10 === 0 && !overheated) {
                let target = null, minDist = Infinity;
                enemies.forEach(e => {
                    const d = Math.sqrt((e.x - player.x) ** 2 + (e.y - player.y) ** 2);
                    if (d < minDist) { minDist = d; target = e; }
                });
                let angle = target ? Math.atan2(target.y - player.y, target.x - player.x) : 0;
                angle += (Math.random() - 0.5) * 0.1;
                bullets.push(new Bullet(player.x, player.y, angle));
                heat += HEAT_PER_SHOT;
                if (heat >= OVERHEAT_THRESHOLD) {
                    overheated = true;
                    effects.push(new Effect(player.x, player.y - 40, "üî•ÈÅéÁÜ±ÔºÅÔºÅ"));
                }
            }

            // Bullets vs Enemies
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].update(); bullets[i].draw();
                if (bullets[i].x < 0 || bullets[i].x > canvas.width || bullets[i].y < 0 || bullets[i].y > canvas.height) { bullets.splice(i, 1); continue; }
                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const dx = bullets[i].x - enemies[j].x, dy = bullets[i].y - enemies[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < enemies[j].size / 2 + bullets[i].size) {
                        const ex = enemies[j].x, ey = enemies[j].y;
                        enemies[j].hp -= 1; hit = true;
                        if (enemies[j].hp <= 0) {
                            if (enemies[j].isBoss) {
                                bossActive = false; score += 10;
                                effects.push(new Effect(ex, ey, bossWords[Math.floor(Math.random() * bossWords.length)]));
                            } else if (enemies[j].type === 'elite') {
                                score += 3; killCount++;
                                effects.push(new Effect(ex, ey, eliteWords[Math.floor(Math.random() * eliteWords.length)]));
                            } else {
                                score++; killCount++;
                                effects.push(new Effect(ex, ey, surrealWords[Math.floor(Math.random() * surrealWords.length)]));
                            }
                            enemies.splice(j, 1);
                            document.getElementById('score').textContent = score;
                        } else {
                            effects.push(new Effect(ex, ey, "Áóõ„Å£"));
                        }
                        break;
                    }
                }
                if (hit) bullets.splice(i, 1);
            }

            // Spawn enemies
            if (!bossActive) {
                if (killCount >= 10) {
                    spawnBoss(); killCount = 0;
                } else {
                    const timeScale = 1 + (elapsedSeconds / 60) * 0.3;
                    const rate = Math.max(10, Math.floor((spawnRate - Math.floor(score / 5)) / timeScale));
                    if (frames % rate === 0) {
                        // Á¢∫Áéá„ÅßÁ®ÆÈ°û„ÇíÈÅ∏„Å∂
                        const roll = Math.random();
                        if (roll < 0.1 + elapsedSeconds * 0.002) {
                            // Á™ÅÈÄ≤Áå´
                            enemies.push(new Enemy('rush'));
                        } else if (roll < 0.18 + elapsedSeconds * 0.001) {
                            // „Ç®„É™„Éº„ÉàÁå´
                            enemies.push(new Enemy('elite'));
                        } else {
                            enemies.push(new Enemy('normal'));
                        }
                    }
                }
            } else {
                if (frames % 120 === 0) enemies.push(new Enemy('normal'));
                // „Éú„ÇπÊà¶‰∏≠„ÇÇÁ™ÅÈÄ≤Áå´„Çí„Åü„Åæ„Å´
                if (frames % 180 === 0 && elapsedSeconds > 20) enemies.push(new Enemy('rush'));
            }

            // ÊïµÂºæ„ÅÆÊõ¥Êñ∞
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                enemyBullets[i].update();
                enemyBullets[i].draw();
                // ÁîªÈù¢Â§ñorÂØøÂëΩÂàá„Çå
                if (enemyBullets[i].life <= 0 || enemyBullets[i].x < -50 || enemyBullets[i].x > canvas.width + 50 || enemyBullets[i].y < -50 || enemyBullets[i].y > canvas.height + 50) {
                    enemyBullets.splice(i, 1); continue;
                }
                // „Éó„É¨„Ç§„É§„Éº„Å®„ÅÆÂΩì„Åü„ÇäÂà§ÂÆö
                const dx = player.x - enemyBullets[i].x, dy = player.y - enemyBullets[i].y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < player.size / 2 + enemyBullets[i].size) {
                    gameState = 'GAMEOVER';
                    showResult();
                    return;
                }
            }

            // Enemies update & collision
            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].update(); enemies[i].draw();
                const dx = player.x - enemies[i].x, dy = player.y - enemies[i].y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < (player.size / 2 + enemies[i].size / 2)) {
                    gameState = 'GAMEOVER';
                    showResult();
                    return;
                }
                // Â£Å„Å´ÂΩì„Åü„Å£„ÅüÊïµ„ÇÇÊ∂à„Åà„Å™„ÅÑÔºàÂ£Å„ÅØ„Éó„É¨„Ç§„É§„Éº„Å†„ÅëÂà∂ÈôêÔºâ
            }

            // Effects
            for (let i = effects.length - 1; i >= 0; i--) {
                effects[i].update(); effects[i].draw();
                if (effects[i].life <= 0) effects.splice(i, 1);
            }

            // Player draw
            if (playerImg.complete && playerImg.naturalWidth !== 0) {
                ctx.save();
                ctx.beginPath(); ctx.arc(player.x, player.y, player.size / 2, 0, Math.PI * 2); ctx.closePath(); ctx.clip();
                ctx.drawImage(playerImg, player.x - player.size / 2, player.y - player.size / 2, player.size, player.size);
                ctx.restore();
            } else {
                ctx.fillStyle = '#fff'; ctx.beginPath();
                ctx.arc(player.x, player.y, player.size / 2, 0, Math.PI * 2); ctx.fill();
            }

            // „Ç™„Éº„Éê„Éº„Éí„Éº„Éà„Ç≤„Éº„Ç∏
            drawHeatGauge();

            frames++;
            requestAnimationFrame(loop);
        }

        // ÂàùÊúüËÉåÊôØ
        bgImg.onload = () => {
            if (gameState === 'TITLE') {
                const r = bgImg.width / bgImg.height, cr = canvas.width / canvas.height;
                let dW, dH, dX, dY;
                if (cr > r) { dW = canvas.width; dH = canvas.width / r; dX = 0; dY = (canvas.height - dH) / 2; }
                else { dW = canvas.height * r; dH = canvas.height; dX = (canvas.width - dW) / 2; dY = 0; }
                ctx.drawImage(bgImg, dX, dY, dW, dH);
            }
        };

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            if (gameState !== 'GAMEOVER') { player.x = canvas.width / 2; player.y = canvas.height / 2; }
        });
    </script>
</body>

</html>